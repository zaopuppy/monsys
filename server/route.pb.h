// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: route.proto

#ifndef PROTOBUF_route_2eproto__INCLUDED
#define PROTOBUF_route_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace letsmidi {
namespace monsys {
namespace protocol {
namespace route {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_route_2eproto();
void protobuf_AssignDesc_route_2eproto();
void protobuf_ShutdownFile_route_2eproto();

class RouteMsg;
class ReqToken;
class ReqTokenRsp;
class Connect;
class ConnectRsp;

enum MsgType {
  REQ_TOKEN = 1,
  REQ_TOKEN_RSP = 2,
  CONNECT = 3,
  CONNECT_RSP = 4
};
bool MsgType_IsValid(int value);
const MsgType MsgType_MIN = REQ_TOKEN;
const MsgType MsgType_MAX = CONNECT_RSP;
const int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgType_descriptor();
inline const ::std::string& MsgType_Name(MsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgType_descriptor(), value);
}
inline bool MsgType_Parse(
    const ::std::string& name, MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
enum AddrType {
  IP_V4 = 1,
  IP_V6 = 2
};
bool AddrType_IsValid(int value);
const AddrType AddrType_MIN = IP_V4;
const AddrType AddrType_MAX = IP_V6;
const int AddrType_ARRAYSIZE = AddrType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AddrType_descriptor();
inline const ::std::string& AddrType_Name(AddrType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AddrType_descriptor(), value);
}
inline bool AddrType_Parse(
    const ::std::string& name, AddrType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AddrType>(
    AddrType_descriptor(), name, value);
}
enum ClientType {
  CLIENT = 1,
  FGW = 2
};
bool ClientType_IsValid(int value);
const ClientType ClientType_MIN = CLIENT;
const ClientType ClientType_MAX = FGW;
const int ClientType_ARRAYSIZE = ClientType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientType_descriptor();
inline const ::std::string& ClientType_Name(ClientType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientType_descriptor(), value);
}
inline bool ClientType_Parse(
    const ::std::string& name, ClientType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientType>(
    ClientType_descriptor(), name, value);
}
// ===================================================================

class RouteMsg : public ::google::protobuf::Message {
 public:
  RouteMsg();
  virtual ~RouteMsg();

  RouteMsg(const RouteMsg& from);

  inline RouteMsg& operator=(const RouteMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RouteMsg& default_instance();

  void Swap(RouteMsg* other);

  // implements Message ----------------------------------------------

  RouteMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RouteMsg& from);
  void MergeFrom(const RouteMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // required .com.letsmidi.monsys.protocol.route.MsgType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::com::letsmidi::monsys::protocol::route::MsgType type() const;
  inline void set_type(::com::letsmidi::monsys::protocol::route::MsgType value);

  // required int32 sequence = 3;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 3;
  inline ::google::protobuf::int32 sequence() const;
  inline void set_sequence(::google::protobuf::int32 value);

  // optional .com.letsmidi.monsys.protocol.route.ReqToken req_token = 10;
  inline bool has_req_token() const;
  inline void clear_req_token();
  static const int kReqTokenFieldNumber = 10;
  inline const ::com::letsmidi::monsys::protocol::route::ReqToken& req_token() const;
  inline ::com::letsmidi::monsys::protocol::route::ReqToken* mutable_req_token();
  inline ::com::letsmidi::monsys::protocol::route::ReqToken* release_req_token();
  inline void set_allocated_req_token(::com::letsmidi::monsys::protocol::route::ReqToken* req_token);

  // optional .com.letsmidi.monsys.protocol.route.ReqTokenRsp req_token_rsp = 11;
  inline bool has_req_token_rsp() const;
  inline void clear_req_token_rsp();
  static const int kReqTokenRspFieldNumber = 11;
  inline const ::com::letsmidi::monsys::protocol::route::ReqTokenRsp& req_token_rsp() const;
  inline ::com::letsmidi::monsys::protocol::route::ReqTokenRsp* mutable_req_token_rsp();
  inline ::com::letsmidi::monsys::protocol::route::ReqTokenRsp* release_req_token_rsp();
  inline void set_allocated_req_token_rsp(::com::letsmidi::monsys::protocol::route::ReqTokenRsp* req_token_rsp);

  // optional .com.letsmidi.monsys.protocol.route.Connect connect = 12;
  inline bool has_connect() const;
  inline void clear_connect();
  static const int kConnectFieldNumber = 12;
  inline const ::com::letsmidi::monsys::protocol::route::Connect& connect() const;
  inline ::com::letsmidi::monsys::protocol::route::Connect* mutable_connect();
  inline ::com::letsmidi::monsys::protocol::route::Connect* release_connect();
  inline void set_allocated_connect(::com::letsmidi::monsys::protocol::route::Connect* connect);

  // optional .com.letsmidi.monsys.protocol.route.ConnectRsp connect_rsp = 13;
  inline bool has_connect_rsp() const;
  inline void clear_connect_rsp();
  static const int kConnectRspFieldNumber = 13;
  inline const ::com::letsmidi::monsys::protocol::route::ConnectRsp& connect_rsp() const;
  inline ::com::letsmidi::monsys::protocol::route::ConnectRsp* mutable_connect_rsp();
  inline ::com::letsmidi::monsys::protocol::route::ConnectRsp* release_connect_rsp();
  inline void set_allocated_connect_rsp(::com::letsmidi::monsys::protocol::route::ConnectRsp* connect_rsp);

  // @@protoc_insertion_point(class_scope:com.letsmidi.monsys.protocol.route.RouteMsg)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_req_token();
  inline void clear_has_req_token();
  inline void set_has_req_token_rsp();
  inline void clear_has_req_token_rsp();
  inline void set_has_connect();
  inline void clear_has_connect();
  inline void set_has_connect_rsp();
  inline void clear_has_connect_rsp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 version_;
  int type_;
  ::com::letsmidi::monsys::protocol::route::ReqToken* req_token_;
  ::com::letsmidi::monsys::protocol::route::ReqTokenRsp* req_token_rsp_;
  ::com::letsmidi::monsys::protocol::route::Connect* connect_;
  ::com::letsmidi::monsys::protocol::route::ConnectRsp* connect_rsp_;
  ::google::protobuf::int32 sequence_;
  friend void  protobuf_AddDesc_route_2eproto();
  friend void protobuf_AssignDesc_route_2eproto();
  friend void protobuf_ShutdownFile_route_2eproto();

  void InitAsDefaultInstance();
  static RouteMsg* default_instance_;
};
// -------------------------------------------------------------------

class ReqToken : public ::google::protobuf::Message {
 public:
  ReqToken();
  virtual ~ReqToken();

  ReqToken(const ReqToken& from);

  inline ReqToken& operator=(const ReqToken& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqToken& default_instance();

  void Swap(ReqToken* other);

  // implements Message ----------------------------------------------

  ReqToken* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqToken& from);
  void MergeFrom(const ReqToken& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // required .com.letsmidi.monsys.protocol.route.AddrType addr_type = 2;
  inline bool has_addr_type() const;
  inline void clear_addr_type();
  static const int kAddrTypeFieldNumber = 2;
  inline ::com::letsmidi::monsys::protocol::route::AddrType addr_type() const;
  inline void set_addr_type(::com::letsmidi::monsys::protocol::route::AddrType value);

  // optional int32 client_ip_v4 = 3;
  inline bool has_client_ip_v4() const;
  inline void clear_client_ip_v4();
  static const int kClientIpV4FieldNumber = 3;
  inline ::google::protobuf::int32 client_ip_v4() const;
  inline void set_client_ip_v4(::google::protobuf::int32 value);

  // optional int32 fgw_ip_v4 = 4;
  inline bool has_fgw_ip_v4() const;
  inline void clear_fgw_ip_v4();
  static const int kFgwIpV4FieldNumber = 4;
  inline ::google::protobuf::int32 fgw_ip_v4() const;
  inline void set_fgw_ip_v4(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.letsmidi.monsys.protocol.route.ReqToken)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_addr_type();
  inline void clear_has_addr_type();
  inline void set_has_client_ip_v4();
  inline void clear_has_client_ip_v4();
  inline void set_has_fgw_ip_v4();
  inline void clear_has_fgw_ip_v4();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* token_;
  int addr_type_;
  ::google::protobuf::int32 client_ip_v4_;
  ::google::protobuf::int32 fgw_ip_v4_;
  friend void  protobuf_AddDesc_route_2eproto();
  friend void protobuf_AssignDesc_route_2eproto();
  friend void protobuf_ShutdownFile_route_2eproto();

  void InitAsDefaultInstance();
  static ReqToken* default_instance_;
};
// -------------------------------------------------------------------

class ReqTokenRsp : public ::google::protobuf::Message {
 public:
  ReqTokenRsp();
  virtual ~ReqTokenRsp();

  ReqTokenRsp(const ReqTokenRsp& from);

  inline ReqTokenRsp& operator=(const ReqTokenRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqTokenRsp& default_instance();

  void Swap(ReqTokenRsp* other);

  // implements Message ----------------------------------------------

  ReqTokenRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqTokenRsp& from);
  void MergeFrom(const ReqTokenRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // required int32 port_for_client = 2;
  inline bool has_port_for_client() const;
  inline void clear_port_for_client();
  static const int kPortForClientFieldNumber = 2;
  inline ::google::protobuf::int32 port_for_client() const;
  inline void set_port_for_client(::google::protobuf::int32 value);

  // required int32 port_for_fgw = 3;
  inline bool has_port_for_fgw() const;
  inline void clear_port_for_fgw();
  static const int kPortForFgwFieldNumber = 3;
  inline ::google::protobuf::int32 port_for_fgw() const;
  inline void set_port_for_fgw(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.letsmidi.monsys.protocol.route.ReqTokenRsp)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_port_for_client();
  inline void clear_has_port_for_client();
  inline void set_has_port_for_fgw();
  inline void clear_has_port_for_fgw();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 code_;
  ::google::protobuf::int32 port_for_client_;
  ::google::protobuf::int32 port_for_fgw_;
  friend void  protobuf_AddDesc_route_2eproto();
  friend void protobuf_AssignDesc_route_2eproto();
  friend void protobuf_ShutdownFile_route_2eproto();

  void InitAsDefaultInstance();
  static ReqTokenRsp* default_instance_;
};
// -------------------------------------------------------------------

class Connect : public ::google::protobuf::Message {
 public:
  Connect();
  virtual ~Connect();

  Connect(const Connect& from);

  inline Connect& operator=(const Connect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Connect& default_instance();

  void Swap(Connect* other);

  // implements Message ----------------------------------------------

  Connect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Connect& from);
  void MergeFrom(const Connect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .com.letsmidi.monsys.protocol.route.ClientType client_type = 1;
  inline bool has_client_type() const;
  inline void clear_client_type();
  static const int kClientTypeFieldNumber = 1;
  inline ::com::letsmidi::monsys::protocol::route::ClientType client_type() const;
  inline void set_client_type(::com::letsmidi::monsys::protocol::route::ClientType value);

  // required string token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:com.letsmidi.monsys.protocol.route.Connect)
 private:
  inline void set_has_client_type();
  inline void clear_has_client_type();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* token_;
  int client_type_;
  friend void  protobuf_AddDesc_route_2eproto();
  friend void protobuf_AssignDesc_route_2eproto();
  friend void protobuf_ShutdownFile_route_2eproto();

  void InitAsDefaultInstance();
  static Connect* default_instance_;
};
// -------------------------------------------------------------------

class ConnectRsp : public ::google::protobuf::Message {
 public:
  ConnectRsp();
  virtual ~ConnectRsp();

  ConnectRsp(const ConnectRsp& from);

  inline ConnectRsp& operator=(const ConnectRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectRsp& default_instance();

  void Swap(ConnectRsp* other);

  // implements Message ----------------------------------------------

  ConnectRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectRsp& from);
  void MergeFrom(const ConnectRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.letsmidi.monsys.protocol.route.ConnectRsp)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 code_;
  friend void  protobuf_AddDesc_route_2eproto();
  friend void protobuf_AssignDesc_route_2eproto();
  friend void protobuf_ShutdownFile_route_2eproto();

  void InitAsDefaultInstance();
  static ConnectRsp* default_instance_;
};
// ===================================================================


// ===================================================================

// RouteMsg

// required int32 version = 1;
inline bool RouteMsg::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RouteMsg::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RouteMsg::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RouteMsg::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 RouteMsg::version() const {
  // @@protoc_insertion_point(field_get:com.letsmidi.monsys.protocol.route.RouteMsg.version)
  return version_;
}
inline void RouteMsg::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:com.letsmidi.monsys.protocol.route.RouteMsg.version)
}

// required .com.letsmidi.monsys.protocol.route.MsgType type = 2;
inline bool RouteMsg::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RouteMsg::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RouteMsg::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RouteMsg::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::com::letsmidi::monsys::protocol::route::MsgType RouteMsg::type() const {
  // @@protoc_insertion_point(field_get:com.letsmidi.monsys.protocol.route.RouteMsg.type)
  return static_cast< ::com::letsmidi::monsys::protocol::route::MsgType >(type_);
}
inline void RouteMsg::set_type(::com::letsmidi::monsys::protocol::route::MsgType value) {
  assert(::com::letsmidi::monsys::protocol::route::MsgType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:com.letsmidi.monsys.protocol.route.RouteMsg.type)
}

// required int32 sequence = 3;
inline bool RouteMsg::has_sequence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RouteMsg::set_has_sequence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RouteMsg::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RouteMsg::clear_sequence() {
  sequence_ = 0;
  clear_has_sequence();
}
inline ::google::protobuf::int32 RouteMsg::sequence() const {
  // @@protoc_insertion_point(field_get:com.letsmidi.monsys.protocol.route.RouteMsg.sequence)
  return sequence_;
}
inline void RouteMsg::set_sequence(::google::protobuf::int32 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:com.letsmidi.monsys.protocol.route.RouteMsg.sequence)
}

// optional .com.letsmidi.monsys.protocol.route.ReqToken req_token = 10;
inline bool RouteMsg::has_req_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RouteMsg::set_has_req_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RouteMsg::clear_has_req_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RouteMsg::clear_req_token() {
  if (req_token_ != NULL) req_token_->::com::letsmidi::monsys::protocol::route::ReqToken::Clear();
  clear_has_req_token();
}
inline const ::com::letsmidi::monsys::protocol::route::ReqToken& RouteMsg::req_token() const {
  // @@protoc_insertion_point(field_get:com.letsmidi.monsys.protocol.route.RouteMsg.req_token)
  return req_token_ != NULL ? *req_token_ : *default_instance_->req_token_;
}
inline ::com::letsmidi::monsys::protocol::route::ReqToken* RouteMsg::mutable_req_token() {
  set_has_req_token();
  if (req_token_ == NULL) req_token_ = new ::com::letsmidi::monsys::protocol::route::ReqToken;
  // @@protoc_insertion_point(field_mutable:com.letsmidi.monsys.protocol.route.RouteMsg.req_token)
  return req_token_;
}
inline ::com::letsmidi::monsys::protocol::route::ReqToken* RouteMsg::release_req_token() {
  clear_has_req_token();
  ::com::letsmidi::monsys::protocol::route::ReqToken* temp = req_token_;
  req_token_ = NULL;
  return temp;
}
inline void RouteMsg::set_allocated_req_token(::com::letsmidi::monsys::protocol::route::ReqToken* req_token) {
  delete req_token_;
  req_token_ = req_token;
  if (req_token) {
    set_has_req_token();
  } else {
    clear_has_req_token();
  }
  // @@protoc_insertion_point(field_set_allocated:com.letsmidi.monsys.protocol.route.RouteMsg.req_token)
}

// optional .com.letsmidi.monsys.protocol.route.ReqTokenRsp req_token_rsp = 11;
inline bool RouteMsg::has_req_token_rsp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RouteMsg::set_has_req_token_rsp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RouteMsg::clear_has_req_token_rsp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RouteMsg::clear_req_token_rsp() {
  if (req_token_rsp_ != NULL) req_token_rsp_->::com::letsmidi::monsys::protocol::route::ReqTokenRsp::Clear();
  clear_has_req_token_rsp();
}
inline const ::com::letsmidi::monsys::protocol::route::ReqTokenRsp& RouteMsg::req_token_rsp() const {
  // @@protoc_insertion_point(field_get:com.letsmidi.monsys.protocol.route.RouteMsg.req_token_rsp)
  return req_token_rsp_ != NULL ? *req_token_rsp_ : *default_instance_->req_token_rsp_;
}
inline ::com::letsmidi::monsys::protocol::route::ReqTokenRsp* RouteMsg::mutable_req_token_rsp() {
  set_has_req_token_rsp();
  if (req_token_rsp_ == NULL) req_token_rsp_ = new ::com::letsmidi::monsys::protocol::route::ReqTokenRsp;
  // @@protoc_insertion_point(field_mutable:com.letsmidi.monsys.protocol.route.RouteMsg.req_token_rsp)
  return req_token_rsp_;
}
inline ::com::letsmidi::monsys::protocol::route::ReqTokenRsp* RouteMsg::release_req_token_rsp() {
  clear_has_req_token_rsp();
  ::com::letsmidi::monsys::protocol::route::ReqTokenRsp* temp = req_token_rsp_;
  req_token_rsp_ = NULL;
  return temp;
}
inline void RouteMsg::set_allocated_req_token_rsp(::com::letsmidi::monsys::protocol::route::ReqTokenRsp* req_token_rsp) {
  delete req_token_rsp_;
  req_token_rsp_ = req_token_rsp;
  if (req_token_rsp) {
    set_has_req_token_rsp();
  } else {
    clear_has_req_token_rsp();
  }
  // @@protoc_insertion_point(field_set_allocated:com.letsmidi.monsys.protocol.route.RouteMsg.req_token_rsp)
}

// optional .com.letsmidi.monsys.protocol.route.Connect connect = 12;
inline bool RouteMsg::has_connect() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RouteMsg::set_has_connect() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RouteMsg::clear_has_connect() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RouteMsg::clear_connect() {
  if (connect_ != NULL) connect_->::com::letsmidi::monsys::protocol::route::Connect::Clear();
  clear_has_connect();
}
inline const ::com::letsmidi::monsys::protocol::route::Connect& RouteMsg::connect() const {
  // @@protoc_insertion_point(field_get:com.letsmidi.monsys.protocol.route.RouteMsg.connect)
  return connect_ != NULL ? *connect_ : *default_instance_->connect_;
}
inline ::com::letsmidi::monsys::protocol::route::Connect* RouteMsg::mutable_connect() {
  set_has_connect();
  if (connect_ == NULL) connect_ = new ::com::letsmidi::monsys::protocol::route::Connect;
  // @@protoc_insertion_point(field_mutable:com.letsmidi.monsys.protocol.route.RouteMsg.connect)
  return connect_;
}
inline ::com::letsmidi::monsys::protocol::route::Connect* RouteMsg::release_connect() {
  clear_has_connect();
  ::com::letsmidi::monsys::protocol::route::Connect* temp = connect_;
  connect_ = NULL;
  return temp;
}
inline void RouteMsg::set_allocated_connect(::com::letsmidi::monsys::protocol::route::Connect* connect) {
  delete connect_;
  connect_ = connect;
  if (connect) {
    set_has_connect();
  } else {
    clear_has_connect();
  }
  // @@protoc_insertion_point(field_set_allocated:com.letsmidi.monsys.protocol.route.RouteMsg.connect)
}

// optional .com.letsmidi.monsys.protocol.route.ConnectRsp connect_rsp = 13;
inline bool RouteMsg::has_connect_rsp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RouteMsg::set_has_connect_rsp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RouteMsg::clear_has_connect_rsp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RouteMsg::clear_connect_rsp() {
  if (connect_rsp_ != NULL) connect_rsp_->::com::letsmidi::monsys::protocol::route::ConnectRsp::Clear();
  clear_has_connect_rsp();
}
inline const ::com::letsmidi::monsys::protocol::route::ConnectRsp& RouteMsg::connect_rsp() const {
  // @@protoc_insertion_point(field_get:com.letsmidi.monsys.protocol.route.RouteMsg.connect_rsp)
  return connect_rsp_ != NULL ? *connect_rsp_ : *default_instance_->connect_rsp_;
}
inline ::com::letsmidi::monsys::protocol::route::ConnectRsp* RouteMsg::mutable_connect_rsp() {
  set_has_connect_rsp();
  if (connect_rsp_ == NULL) connect_rsp_ = new ::com::letsmidi::monsys::protocol::route::ConnectRsp;
  // @@protoc_insertion_point(field_mutable:com.letsmidi.monsys.protocol.route.RouteMsg.connect_rsp)
  return connect_rsp_;
}
inline ::com::letsmidi::monsys::protocol::route::ConnectRsp* RouteMsg::release_connect_rsp() {
  clear_has_connect_rsp();
  ::com::letsmidi::monsys::protocol::route::ConnectRsp* temp = connect_rsp_;
  connect_rsp_ = NULL;
  return temp;
}
inline void RouteMsg::set_allocated_connect_rsp(::com::letsmidi::monsys::protocol::route::ConnectRsp* connect_rsp) {
  delete connect_rsp_;
  connect_rsp_ = connect_rsp;
  if (connect_rsp) {
    set_has_connect_rsp();
  } else {
    clear_has_connect_rsp();
  }
  // @@protoc_insertion_point(field_set_allocated:com.letsmidi.monsys.protocol.route.RouteMsg.connect_rsp)
}

// -------------------------------------------------------------------

// ReqToken

// required string token = 1;
inline bool ReqToken::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqToken::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqToken::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqToken::clear_token() {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& ReqToken::token() const {
  // @@protoc_insertion_point(field_get:com.letsmidi.monsys.protocol.route.ReqToken.token)
  return *token_;
}
inline void ReqToken::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set:com.letsmidi.monsys.protocol.route.ReqToken.token)
}
inline void ReqToken::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.letsmidi.monsys.protocol.route.ReqToken.token)
}
inline void ReqToken::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.letsmidi.monsys.protocol.route.ReqToken.token)
}
inline ::std::string* ReqToken::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.letsmidi.monsys.protocol.route.ReqToken.token)
  return token_;
}
inline ::std::string* ReqToken::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReqToken::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.letsmidi.monsys.protocol.route.ReqToken.token)
}

// required .com.letsmidi.monsys.protocol.route.AddrType addr_type = 2;
inline bool ReqToken::has_addr_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqToken::set_has_addr_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqToken::clear_has_addr_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqToken::clear_addr_type() {
  addr_type_ = 1;
  clear_has_addr_type();
}
inline ::com::letsmidi::monsys::protocol::route::AddrType ReqToken::addr_type() const {
  // @@protoc_insertion_point(field_get:com.letsmidi.monsys.protocol.route.ReqToken.addr_type)
  return static_cast< ::com::letsmidi::monsys::protocol::route::AddrType >(addr_type_);
}
inline void ReqToken::set_addr_type(::com::letsmidi::monsys::protocol::route::AddrType value) {
  assert(::com::letsmidi::monsys::protocol::route::AddrType_IsValid(value));
  set_has_addr_type();
  addr_type_ = value;
  // @@protoc_insertion_point(field_set:com.letsmidi.monsys.protocol.route.ReqToken.addr_type)
}

// optional int32 client_ip_v4 = 3;
inline bool ReqToken::has_client_ip_v4() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqToken::set_has_client_ip_v4() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqToken::clear_has_client_ip_v4() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqToken::clear_client_ip_v4() {
  client_ip_v4_ = 0;
  clear_has_client_ip_v4();
}
inline ::google::protobuf::int32 ReqToken::client_ip_v4() const {
  // @@protoc_insertion_point(field_get:com.letsmidi.monsys.protocol.route.ReqToken.client_ip_v4)
  return client_ip_v4_;
}
inline void ReqToken::set_client_ip_v4(::google::protobuf::int32 value) {
  set_has_client_ip_v4();
  client_ip_v4_ = value;
  // @@protoc_insertion_point(field_set:com.letsmidi.monsys.protocol.route.ReqToken.client_ip_v4)
}

// optional int32 fgw_ip_v4 = 4;
inline bool ReqToken::has_fgw_ip_v4() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqToken::set_has_fgw_ip_v4() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqToken::clear_has_fgw_ip_v4() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqToken::clear_fgw_ip_v4() {
  fgw_ip_v4_ = 0;
  clear_has_fgw_ip_v4();
}
inline ::google::protobuf::int32 ReqToken::fgw_ip_v4() const {
  // @@protoc_insertion_point(field_get:com.letsmidi.monsys.protocol.route.ReqToken.fgw_ip_v4)
  return fgw_ip_v4_;
}
inline void ReqToken::set_fgw_ip_v4(::google::protobuf::int32 value) {
  set_has_fgw_ip_v4();
  fgw_ip_v4_ = value;
  // @@protoc_insertion_point(field_set:com.letsmidi.monsys.protocol.route.ReqToken.fgw_ip_v4)
}

// -------------------------------------------------------------------

// ReqTokenRsp

// required int32 code = 1;
inline bool ReqTokenRsp::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqTokenRsp::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqTokenRsp::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqTokenRsp::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ReqTokenRsp::code() const {
  // @@protoc_insertion_point(field_get:com.letsmidi.monsys.protocol.route.ReqTokenRsp.code)
  return code_;
}
inline void ReqTokenRsp::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:com.letsmidi.monsys.protocol.route.ReqTokenRsp.code)
}

// required int32 port_for_client = 2;
inline bool ReqTokenRsp::has_port_for_client() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqTokenRsp::set_has_port_for_client() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqTokenRsp::clear_has_port_for_client() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqTokenRsp::clear_port_for_client() {
  port_for_client_ = 0;
  clear_has_port_for_client();
}
inline ::google::protobuf::int32 ReqTokenRsp::port_for_client() const {
  // @@protoc_insertion_point(field_get:com.letsmidi.monsys.protocol.route.ReqTokenRsp.port_for_client)
  return port_for_client_;
}
inline void ReqTokenRsp::set_port_for_client(::google::protobuf::int32 value) {
  set_has_port_for_client();
  port_for_client_ = value;
  // @@protoc_insertion_point(field_set:com.letsmidi.monsys.protocol.route.ReqTokenRsp.port_for_client)
}

// required int32 port_for_fgw = 3;
inline bool ReqTokenRsp::has_port_for_fgw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqTokenRsp::set_has_port_for_fgw() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqTokenRsp::clear_has_port_for_fgw() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqTokenRsp::clear_port_for_fgw() {
  port_for_fgw_ = 0;
  clear_has_port_for_fgw();
}
inline ::google::protobuf::int32 ReqTokenRsp::port_for_fgw() const {
  // @@protoc_insertion_point(field_get:com.letsmidi.monsys.protocol.route.ReqTokenRsp.port_for_fgw)
  return port_for_fgw_;
}
inline void ReqTokenRsp::set_port_for_fgw(::google::protobuf::int32 value) {
  set_has_port_for_fgw();
  port_for_fgw_ = value;
  // @@protoc_insertion_point(field_set:com.letsmidi.monsys.protocol.route.ReqTokenRsp.port_for_fgw)
}

// -------------------------------------------------------------------

// Connect

// required .com.letsmidi.monsys.protocol.route.ClientType client_type = 1;
inline bool Connect::has_client_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Connect::set_has_client_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Connect::clear_has_client_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Connect::clear_client_type() {
  client_type_ = 1;
  clear_has_client_type();
}
inline ::com::letsmidi::monsys::protocol::route::ClientType Connect::client_type() const {
  // @@protoc_insertion_point(field_get:com.letsmidi.monsys.protocol.route.Connect.client_type)
  return static_cast< ::com::letsmidi::monsys::protocol::route::ClientType >(client_type_);
}
inline void Connect::set_client_type(::com::letsmidi::monsys::protocol::route::ClientType value) {
  assert(::com::letsmidi::monsys::protocol::route::ClientType_IsValid(value));
  set_has_client_type();
  client_type_ = value;
  // @@protoc_insertion_point(field_set:com.letsmidi.monsys.protocol.route.Connect.client_type)
}

// required string token = 2;
inline bool Connect::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Connect::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Connect::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Connect::clear_token() {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& Connect::token() const {
  // @@protoc_insertion_point(field_get:com.letsmidi.monsys.protocol.route.Connect.token)
  return *token_;
}
inline void Connect::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set:com.letsmidi.monsys.protocol.route.Connect.token)
}
inline void Connect::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.letsmidi.monsys.protocol.route.Connect.token)
}
inline void Connect::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.letsmidi.monsys.protocol.route.Connect.token)
}
inline ::std::string* Connect::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.letsmidi.monsys.protocol.route.Connect.token)
  return token_;
}
inline ::std::string* Connect::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Connect::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.letsmidi.monsys.protocol.route.Connect.token)
}

// -------------------------------------------------------------------

// ConnectRsp

// required int32 code = 1;
inline bool ConnectRsp::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectRsp::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectRsp::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectRsp::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ConnectRsp::code() const {
  // @@protoc_insertion_point(field_get:com.letsmidi.monsys.protocol.route.ConnectRsp.code)
  return code_;
}
inline void ConnectRsp::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:com.letsmidi.monsys.protocol.route.ConnectRsp.code)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace route
}  // namespace protocol
}  // namespace monsys
}  // namespace letsmidi
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::com::letsmidi::monsys::protocol::route::MsgType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::letsmidi::monsys::protocol::route::MsgType>() {
  return ::com::letsmidi::monsys::protocol::route::MsgType_descriptor();
}
template <> struct is_proto_enum< ::com::letsmidi::monsys::protocol::route::AddrType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::letsmidi::monsys::protocol::route::AddrType>() {
  return ::com::letsmidi::monsys::protocol::route::AddrType_descriptor();
}
template <> struct is_proto_enum< ::com::letsmidi::monsys::protocol::route::ClientType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::letsmidi::monsys::protocol::route::ClientType>() {
  return ::com::letsmidi::monsys::protocol::route::ClientType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_route_2eproto__INCLUDED
