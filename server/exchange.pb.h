// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: exchange.proto

#ifndef PROTOBUF_exchange_2eproto__INCLUDED
#define PROTOBUF_exchange_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace letsmidi {
namespace monsys {
namespace protocol {
namespace exchange {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_exchange_2eproto();
void protobuf_AssignDesc_exchange_2eproto();
void protobuf_ShutdownFile_exchange_2eproto();

class ExchangeMsg;
class RequestExchange;
class RequestExchangeRsp;
class Connect;
class ConnectRsp;

enum MsgType {
  REQUEST_EXCHANGE = 1,
  REQUEST_EXCHANGE_RSP = 2,
  CONNECT = 3,
  CONNECT_RSP = 4
};
bool MsgType_IsValid(int value);
const MsgType MsgType_MIN = REQUEST_EXCHANGE;
const MsgType MsgType_MAX = CONNECT_RSP;
const int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgType_descriptor();
inline const ::std::string& MsgType_Name(MsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgType_descriptor(), value);
}
inline bool MsgType_Parse(
    const ::std::string& name, MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
// ===================================================================

class ExchangeMsg : public ::google::protobuf::Message {
 public:
  ExchangeMsg();
  virtual ~ExchangeMsg();

  ExchangeMsg(const ExchangeMsg& from);

  inline ExchangeMsg& operator=(const ExchangeMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExchangeMsg& default_instance();

  void Swap(ExchangeMsg* other);

  // implements Message ----------------------------------------------

  ExchangeMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExchangeMsg& from);
  void MergeFrom(const ExchangeMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // required .com.letsmidi.monsys.protocol.exchange.MsgType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::com::letsmidi::monsys::protocol::exchange::MsgType type() const;
  inline void set_type(::com::letsmidi::monsys::protocol::exchange::MsgType value);

  // required uint32 sequence = 3;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 3;
  inline ::google::protobuf::uint32 sequence() const;
  inline void set_sequence(::google::protobuf::uint32 value);

  // optional .com.letsmidi.monsys.protocol.exchange.RequestExchange request_exchange = 5;
  inline bool has_request_exchange() const;
  inline void clear_request_exchange();
  static const int kRequestExchangeFieldNumber = 5;
  inline const ::com::letsmidi::monsys::protocol::exchange::RequestExchange& request_exchange() const;
  inline ::com::letsmidi::monsys::protocol::exchange::RequestExchange* mutable_request_exchange();
  inline ::com::letsmidi::monsys::protocol::exchange::RequestExchange* release_request_exchange();
  inline void set_allocated_request_exchange(::com::letsmidi::monsys::protocol::exchange::RequestExchange* request_exchange);

  // optional .com.letsmidi.monsys.protocol.exchange.RequestExchangeRsp request_exchange_rsp = 6;
  inline bool has_request_exchange_rsp() const;
  inline void clear_request_exchange_rsp();
  static const int kRequestExchangeRspFieldNumber = 6;
  inline const ::com::letsmidi::monsys::protocol::exchange::RequestExchangeRsp& request_exchange_rsp() const;
  inline ::com::letsmidi::monsys::protocol::exchange::RequestExchangeRsp* mutable_request_exchange_rsp();
  inline ::com::letsmidi::monsys::protocol::exchange::RequestExchangeRsp* release_request_exchange_rsp();
  inline void set_allocated_request_exchange_rsp(::com::letsmidi::monsys::protocol::exchange::RequestExchangeRsp* request_exchange_rsp);

  // optional .com.letsmidi.monsys.protocol.exchange.Connect connect = 7;
  inline bool has_connect() const;
  inline void clear_connect();
  static const int kConnectFieldNumber = 7;
  inline const ::com::letsmidi::monsys::protocol::exchange::Connect& connect() const;
  inline ::com::letsmidi::monsys::protocol::exchange::Connect* mutable_connect();
  inline ::com::letsmidi::monsys::protocol::exchange::Connect* release_connect();
  inline void set_allocated_connect(::com::letsmidi::monsys::protocol::exchange::Connect* connect);

  // optional .com.letsmidi.monsys.protocol.exchange.ConnectRsp connect_rsp = 8;
  inline bool has_connect_rsp() const;
  inline void clear_connect_rsp();
  static const int kConnectRspFieldNumber = 8;
  inline const ::com::letsmidi::monsys::protocol::exchange::ConnectRsp& connect_rsp() const;
  inline ::com::letsmidi::monsys::protocol::exchange::ConnectRsp* mutable_connect_rsp();
  inline ::com::letsmidi::monsys::protocol::exchange::ConnectRsp* release_connect_rsp();
  inline void set_allocated_connect_rsp(::com::letsmidi::monsys::protocol::exchange::ConnectRsp* connect_rsp);

  // @@protoc_insertion_point(class_scope:com.letsmidi.monsys.protocol.exchange.ExchangeMsg)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_request_exchange();
  inline void clear_has_request_exchange();
  inline void set_has_request_exchange_rsp();
  inline void clear_has_request_exchange_rsp();
  inline void set_has_connect();
  inline void clear_has_connect();
  inline void set_has_connect_rsp();
  inline void clear_has_connect_rsp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 version_;
  int type_;
  ::com::letsmidi::monsys::protocol::exchange::RequestExchange* request_exchange_;
  ::com::letsmidi::monsys::protocol::exchange::RequestExchangeRsp* request_exchange_rsp_;
  ::com::letsmidi::monsys::protocol::exchange::Connect* connect_;
  ::com::letsmidi::monsys::protocol::exchange::ConnectRsp* connect_rsp_;
  ::google::protobuf::uint32 sequence_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_exchange_2eproto();
  friend void protobuf_AssignDesc_exchange_2eproto();
  friend void protobuf_ShutdownFile_exchange_2eproto();

  void InitAsDefaultInstance();
  static ExchangeMsg* default_instance_;
};
// -------------------------------------------------------------------

class RequestExchange : public ::google::protobuf::Message {
 public:
  RequestExchange();
  virtual ~RequestExchange();

  RequestExchange(const RequestExchange& from);

  inline RequestExchange& operator=(const RequestExchange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestExchange& default_instance();

  void Swap(RequestExchange* other);

  // implements Message ----------------------------------------------

  RequestExchange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestExchange& from);
  void MergeFrom(const RequestExchange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:com.letsmidi.monsys.protocol.exchange.RequestExchange)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_exchange_2eproto();
  friend void protobuf_AssignDesc_exchange_2eproto();
  friend void protobuf_ShutdownFile_exchange_2eproto();

  void InitAsDefaultInstance();
  static RequestExchange* default_instance_;
};
// -------------------------------------------------------------------

class RequestExchangeRsp : public ::google::protobuf::Message {
 public:
  RequestExchangeRsp();
  virtual ~RequestExchangeRsp();

  RequestExchangeRsp(const RequestExchangeRsp& from);

  inline RequestExchangeRsp& operator=(const RequestExchangeRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestExchangeRsp& default_instance();

  void Swap(RequestExchangeRsp* other);

  // implements Message ----------------------------------------------

  RequestExchangeRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestExchangeRsp& from);
  void MergeFrom(const RequestExchangeRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // required string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string peer_id1 = 3;
  inline bool has_peer_id1() const;
  inline void clear_peer_id1();
  static const int kPeerId1FieldNumber = 3;
  inline const ::std::string& peer_id1() const;
  inline void set_peer_id1(const ::std::string& value);
  inline void set_peer_id1(const char* value);
  inline void set_peer_id1(const char* value, size_t size);
  inline ::std::string* mutable_peer_id1();
  inline ::std::string* release_peer_id1();
  inline void set_allocated_peer_id1(::std::string* peer_id1);

  // required string peer_id2 = 4;
  inline bool has_peer_id2() const;
  inline void clear_peer_id2();
  static const int kPeerId2FieldNumber = 4;
  inline const ::std::string& peer_id2() const;
  inline void set_peer_id2(const ::std::string& value);
  inline void set_peer_id2(const char* value);
  inline void set_peer_id2(const char* value, size_t size);
  inline ::std::string* mutable_peer_id2();
  inline ::std::string* release_peer_id2();
  inline void set_allocated_peer_id2(::std::string* peer_id2);

  // @@protoc_insertion_point(class_scope:com.letsmidi.monsys.protocol.exchange.RequestExchangeRsp)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_peer_id1();
  inline void clear_has_peer_id1();
  inline void set_has_peer_id2();
  inline void clear_has_peer_id2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* peer_id1_;
  ::std::string* peer_id2_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_exchange_2eproto();
  friend void protobuf_AssignDesc_exchange_2eproto();
  friend void protobuf_ShutdownFile_exchange_2eproto();

  void InitAsDefaultInstance();
  static RequestExchangeRsp* default_instance_;
};
// -------------------------------------------------------------------

class Connect : public ::google::protobuf::Message {
 public:
  Connect();
  virtual ~Connect();

  Connect(const Connect& from);

  inline Connect& operator=(const Connect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Connect& default_instance();

  void Swap(Connect* other);

  // implements Message ----------------------------------------------

  Connect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Connect& from);
  void MergeFrom(const Connect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string peer_id = 2;
  inline bool has_peer_id() const;
  inline void clear_peer_id();
  static const int kPeerIdFieldNumber = 2;
  inline const ::std::string& peer_id() const;
  inline void set_peer_id(const ::std::string& value);
  inline void set_peer_id(const char* value);
  inline void set_peer_id(const char* value, size_t size);
  inline ::std::string* mutable_peer_id();
  inline ::std::string* release_peer_id();
  inline void set_allocated_peer_id(::std::string* peer_id);

  // @@protoc_insertion_point(class_scope:com.letsmidi.monsys.protocol.exchange.Connect)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_peer_id();
  inline void clear_has_peer_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* peer_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_exchange_2eproto();
  friend void protobuf_AssignDesc_exchange_2eproto();
  friend void protobuf_ShutdownFile_exchange_2eproto();

  void InitAsDefaultInstance();
  static Connect* default_instance_;
};
// -------------------------------------------------------------------

class ConnectRsp : public ::google::protobuf::Message {
 public:
  ConnectRsp();
  virtual ~ConnectRsp();

  ConnectRsp(const ConnectRsp& from);

  inline ConnectRsp& operator=(const ConnectRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectRsp& default_instance();

  void Swap(ConnectRsp* other);

  // implements Message ----------------------------------------------

  ConnectRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectRsp& from);
  void MergeFrom(const ConnectRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.letsmidi.monsys.protocol.exchange.ConnectRsp)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_exchange_2eproto();
  friend void protobuf_AssignDesc_exchange_2eproto();
  friend void protobuf_ShutdownFile_exchange_2eproto();

  void InitAsDefaultInstance();
  static ConnectRsp* default_instance_;
};
// ===================================================================


// ===================================================================

// ExchangeMsg

// required uint32 version = 1;
inline bool ExchangeMsg::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExchangeMsg::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExchangeMsg::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExchangeMsg::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 ExchangeMsg::version() const {
  return version_;
}
inline void ExchangeMsg::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// required .com.letsmidi.monsys.protocol.exchange.MsgType type = 2;
inline bool ExchangeMsg::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExchangeMsg::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExchangeMsg::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExchangeMsg::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::com::letsmidi::monsys::protocol::exchange::MsgType ExchangeMsg::type() const {
  return static_cast< ::com::letsmidi::monsys::protocol::exchange::MsgType >(type_);
}
inline void ExchangeMsg::set_type(::com::letsmidi::monsys::protocol::exchange::MsgType value) {
  assert(::com::letsmidi::monsys::protocol::exchange::MsgType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required uint32 sequence = 3;
inline bool ExchangeMsg::has_sequence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExchangeMsg::set_has_sequence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExchangeMsg::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExchangeMsg::clear_sequence() {
  sequence_ = 0u;
  clear_has_sequence();
}
inline ::google::protobuf::uint32 ExchangeMsg::sequence() const {
  return sequence_;
}
inline void ExchangeMsg::set_sequence(::google::protobuf::uint32 value) {
  set_has_sequence();
  sequence_ = value;
}

// optional .com.letsmidi.monsys.protocol.exchange.RequestExchange request_exchange = 5;
inline bool ExchangeMsg::has_request_exchange() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExchangeMsg::set_has_request_exchange() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExchangeMsg::clear_has_request_exchange() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExchangeMsg::clear_request_exchange() {
  if (request_exchange_ != NULL) request_exchange_->::com::letsmidi::monsys::protocol::exchange::RequestExchange::Clear();
  clear_has_request_exchange();
}
inline const ::com::letsmidi::monsys::protocol::exchange::RequestExchange& ExchangeMsg::request_exchange() const {
  return request_exchange_ != NULL ? *request_exchange_ : *default_instance_->request_exchange_;
}
inline ::com::letsmidi::monsys::protocol::exchange::RequestExchange* ExchangeMsg::mutable_request_exchange() {
  set_has_request_exchange();
  if (request_exchange_ == NULL) request_exchange_ = new ::com::letsmidi::monsys::protocol::exchange::RequestExchange;
  return request_exchange_;
}
inline ::com::letsmidi::monsys::protocol::exchange::RequestExchange* ExchangeMsg::release_request_exchange() {
  clear_has_request_exchange();
  ::com::letsmidi::monsys::protocol::exchange::RequestExchange* temp = request_exchange_;
  request_exchange_ = NULL;
  return temp;
}
inline void ExchangeMsg::set_allocated_request_exchange(::com::letsmidi::monsys::protocol::exchange::RequestExchange* request_exchange) {
  delete request_exchange_;
  request_exchange_ = request_exchange;
  if (request_exchange) {
    set_has_request_exchange();
  } else {
    clear_has_request_exchange();
  }
}

// optional .com.letsmidi.monsys.protocol.exchange.RequestExchangeRsp request_exchange_rsp = 6;
inline bool ExchangeMsg::has_request_exchange_rsp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExchangeMsg::set_has_request_exchange_rsp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExchangeMsg::clear_has_request_exchange_rsp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExchangeMsg::clear_request_exchange_rsp() {
  if (request_exchange_rsp_ != NULL) request_exchange_rsp_->::com::letsmidi::monsys::protocol::exchange::RequestExchangeRsp::Clear();
  clear_has_request_exchange_rsp();
}
inline const ::com::letsmidi::monsys::protocol::exchange::RequestExchangeRsp& ExchangeMsg::request_exchange_rsp() const {
  return request_exchange_rsp_ != NULL ? *request_exchange_rsp_ : *default_instance_->request_exchange_rsp_;
}
inline ::com::letsmidi::monsys::protocol::exchange::RequestExchangeRsp* ExchangeMsg::mutable_request_exchange_rsp() {
  set_has_request_exchange_rsp();
  if (request_exchange_rsp_ == NULL) request_exchange_rsp_ = new ::com::letsmidi::monsys::protocol::exchange::RequestExchangeRsp;
  return request_exchange_rsp_;
}
inline ::com::letsmidi::monsys::protocol::exchange::RequestExchangeRsp* ExchangeMsg::release_request_exchange_rsp() {
  clear_has_request_exchange_rsp();
  ::com::letsmidi::monsys::protocol::exchange::RequestExchangeRsp* temp = request_exchange_rsp_;
  request_exchange_rsp_ = NULL;
  return temp;
}
inline void ExchangeMsg::set_allocated_request_exchange_rsp(::com::letsmidi::monsys::protocol::exchange::RequestExchangeRsp* request_exchange_rsp) {
  delete request_exchange_rsp_;
  request_exchange_rsp_ = request_exchange_rsp;
  if (request_exchange_rsp) {
    set_has_request_exchange_rsp();
  } else {
    clear_has_request_exchange_rsp();
  }
}

// optional .com.letsmidi.monsys.protocol.exchange.Connect connect = 7;
inline bool ExchangeMsg::has_connect() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExchangeMsg::set_has_connect() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ExchangeMsg::clear_has_connect() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ExchangeMsg::clear_connect() {
  if (connect_ != NULL) connect_->::com::letsmidi::monsys::protocol::exchange::Connect::Clear();
  clear_has_connect();
}
inline const ::com::letsmidi::monsys::protocol::exchange::Connect& ExchangeMsg::connect() const {
  return connect_ != NULL ? *connect_ : *default_instance_->connect_;
}
inline ::com::letsmidi::monsys::protocol::exchange::Connect* ExchangeMsg::mutable_connect() {
  set_has_connect();
  if (connect_ == NULL) connect_ = new ::com::letsmidi::monsys::protocol::exchange::Connect;
  return connect_;
}
inline ::com::letsmidi::monsys::protocol::exchange::Connect* ExchangeMsg::release_connect() {
  clear_has_connect();
  ::com::letsmidi::monsys::protocol::exchange::Connect* temp = connect_;
  connect_ = NULL;
  return temp;
}
inline void ExchangeMsg::set_allocated_connect(::com::letsmidi::monsys::protocol::exchange::Connect* connect) {
  delete connect_;
  connect_ = connect;
  if (connect) {
    set_has_connect();
  } else {
    clear_has_connect();
  }
}

// optional .com.letsmidi.monsys.protocol.exchange.ConnectRsp connect_rsp = 8;
inline bool ExchangeMsg::has_connect_rsp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExchangeMsg::set_has_connect_rsp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ExchangeMsg::clear_has_connect_rsp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ExchangeMsg::clear_connect_rsp() {
  if (connect_rsp_ != NULL) connect_rsp_->::com::letsmidi::monsys::protocol::exchange::ConnectRsp::Clear();
  clear_has_connect_rsp();
}
inline const ::com::letsmidi::monsys::protocol::exchange::ConnectRsp& ExchangeMsg::connect_rsp() const {
  return connect_rsp_ != NULL ? *connect_rsp_ : *default_instance_->connect_rsp_;
}
inline ::com::letsmidi::monsys::protocol::exchange::ConnectRsp* ExchangeMsg::mutable_connect_rsp() {
  set_has_connect_rsp();
  if (connect_rsp_ == NULL) connect_rsp_ = new ::com::letsmidi::monsys::protocol::exchange::ConnectRsp;
  return connect_rsp_;
}
inline ::com::letsmidi::monsys::protocol::exchange::ConnectRsp* ExchangeMsg::release_connect_rsp() {
  clear_has_connect_rsp();
  ::com::letsmidi::monsys::protocol::exchange::ConnectRsp* temp = connect_rsp_;
  connect_rsp_ = NULL;
  return temp;
}
inline void ExchangeMsg::set_allocated_connect_rsp(::com::letsmidi::monsys::protocol::exchange::ConnectRsp* connect_rsp) {
  delete connect_rsp_;
  connect_rsp_ = connect_rsp;
  if (connect_rsp) {
    set_has_connect_rsp();
  } else {
    clear_has_connect_rsp();
  }
}

// -------------------------------------------------------------------

// RequestExchange

// -------------------------------------------------------------------

// RequestExchangeRsp

// required int32 code = 1;
inline bool RequestExchangeRsp::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestExchangeRsp::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestExchangeRsp::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestExchangeRsp::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 RequestExchangeRsp::code() const {
  return code_;
}
inline void RequestExchangeRsp::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// required string id = 2;
inline bool RequestExchangeRsp::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestExchangeRsp::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestExchangeRsp::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestExchangeRsp::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& RequestExchangeRsp::id() const {
  return *id_;
}
inline void RequestExchangeRsp::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void RequestExchangeRsp::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void RequestExchangeRsp::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestExchangeRsp::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* RequestExchangeRsp::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestExchangeRsp::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string peer_id1 = 3;
inline bool RequestExchangeRsp::has_peer_id1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestExchangeRsp::set_has_peer_id1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestExchangeRsp::clear_has_peer_id1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestExchangeRsp::clear_peer_id1() {
  if (peer_id1_ != &::google::protobuf::internal::kEmptyString) {
    peer_id1_->clear();
  }
  clear_has_peer_id1();
}
inline const ::std::string& RequestExchangeRsp::peer_id1() const {
  return *peer_id1_;
}
inline void RequestExchangeRsp::set_peer_id1(const ::std::string& value) {
  set_has_peer_id1();
  if (peer_id1_ == &::google::protobuf::internal::kEmptyString) {
    peer_id1_ = new ::std::string;
  }
  peer_id1_->assign(value);
}
inline void RequestExchangeRsp::set_peer_id1(const char* value) {
  set_has_peer_id1();
  if (peer_id1_ == &::google::protobuf::internal::kEmptyString) {
    peer_id1_ = new ::std::string;
  }
  peer_id1_->assign(value);
}
inline void RequestExchangeRsp::set_peer_id1(const char* value, size_t size) {
  set_has_peer_id1();
  if (peer_id1_ == &::google::protobuf::internal::kEmptyString) {
    peer_id1_ = new ::std::string;
  }
  peer_id1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestExchangeRsp::mutable_peer_id1() {
  set_has_peer_id1();
  if (peer_id1_ == &::google::protobuf::internal::kEmptyString) {
    peer_id1_ = new ::std::string;
  }
  return peer_id1_;
}
inline ::std::string* RequestExchangeRsp::release_peer_id1() {
  clear_has_peer_id1();
  if (peer_id1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peer_id1_;
    peer_id1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestExchangeRsp::set_allocated_peer_id1(::std::string* peer_id1) {
  if (peer_id1_ != &::google::protobuf::internal::kEmptyString) {
    delete peer_id1_;
  }
  if (peer_id1) {
    set_has_peer_id1();
    peer_id1_ = peer_id1;
  } else {
    clear_has_peer_id1();
    peer_id1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string peer_id2 = 4;
inline bool RequestExchangeRsp::has_peer_id2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestExchangeRsp::set_has_peer_id2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestExchangeRsp::clear_has_peer_id2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestExchangeRsp::clear_peer_id2() {
  if (peer_id2_ != &::google::protobuf::internal::kEmptyString) {
    peer_id2_->clear();
  }
  clear_has_peer_id2();
}
inline const ::std::string& RequestExchangeRsp::peer_id2() const {
  return *peer_id2_;
}
inline void RequestExchangeRsp::set_peer_id2(const ::std::string& value) {
  set_has_peer_id2();
  if (peer_id2_ == &::google::protobuf::internal::kEmptyString) {
    peer_id2_ = new ::std::string;
  }
  peer_id2_->assign(value);
}
inline void RequestExchangeRsp::set_peer_id2(const char* value) {
  set_has_peer_id2();
  if (peer_id2_ == &::google::protobuf::internal::kEmptyString) {
    peer_id2_ = new ::std::string;
  }
  peer_id2_->assign(value);
}
inline void RequestExchangeRsp::set_peer_id2(const char* value, size_t size) {
  set_has_peer_id2();
  if (peer_id2_ == &::google::protobuf::internal::kEmptyString) {
    peer_id2_ = new ::std::string;
  }
  peer_id2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestExchangeRsp::mutable_peer_id2() {
  set_has_peer_id2();
  if (peer_id2_ == &::google::protobuf::internal::kEmptyString) {
    peer_id2_ = new ::std::string;
  }
  return peer_id2_;
}
inline ::std::string* RequestExchangeRsp::release_peer_id2() {
  clear_has_peer_id2();
  if (peer_id2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peer_id2_;
    peer_id2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestExchangeRsp::set_allocated_peer_id2(::std::string* peer_id2) {
  if (peer_id2_ != &::google::protobuf::internal::kEmptyString) {
    delete peer_id2_;
  }
  if (peer_id2) {
    set_has_peer_id2();
    peer_id2_ = peer_id2;
  } else {
    clear_has_peer_id2();
    peer_id2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Connect

// required string id = 1;
inline bool Connect::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Connect::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Connect::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Connect::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Connect::id() const {
  return *id_;
}
inline void Connect::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Connect::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Connect::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Connect::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Connect::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Connect::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string peer_id = 2;
inline bool Connect::has_peer_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Connect::set_has_peer_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Connect::clear_has_peer_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Connect::clear_peer_id() {
  if (peer_id_ != &::google::protobuf::internal::kEmptyString) {
    peer_id_->clear();
  }
  clear_has_peer_id();
}
inline const ::std::string& Connect::peer_id() const {
  return *peer_id_;
}
inline void Connect::set_peer_id(const ::std::string& value) {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_id_ = new ::std::string;
  }
  peer_id_->assign(value);
}
inline void Connect::set_peer_id(const char* value) {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_id_ = new ::std::string;
  }
  peer_id_->assign(value);
}
inline void Connect::set_peer_id(const char* value, size_t size) {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_id_ = new ::std::string;
  }
  peer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Connect::mutable_peer_id() {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::kEmptyString) {
    peer_id_ = new ::std::string;
  }
  return peer_id_;
}
inline ::std::string* Connect::release_peer_id() {
  clear_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peer_id_;
    peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Connect::set_allocated_peer_id(::std::string* peer_id) {
  if (peer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete peer_id_;
  }
  if (peer_id) {
    set_has_peer_id();
    peer_id_ = peer_id;
  } else {
    clear_has_peer_id();
    peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ConnectRsp

// required int32 code = 1;
inline bool ConnectRsp::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectRsp::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectRsp::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectRsp::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ConnectRsp::code() const {
  return code_;
}
inline void ConnectRsp::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace exchange
}  // namespace protocol
}  // namespace monsys
}  // namespace letsmidi
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::letsmidi::monsys::protocol::exchange::MsgType>() {
  return ::com::letsmidi::monsys::protocol::exchange::MsgType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_exchange_2eproto__INCLUDED
